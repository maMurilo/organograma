<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <title>Organograma Fazenda ‚Üí √Årea ‚Üí L√≠der ‚Üí Liderados</title>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
  <script src="https://d3js.org/d3.v7.min.js"></script>

  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f4f4f4;
      margin: 20px;
      overflow: hidden;
    }

    h2 {
      text-align: center;
    }

    svg {
      width: 100%;
      height: 85vh;
      border: 1px solid #ccc;
      background: #fff;
    }

    .node rect {
      stroke: #4285f4;
      stroke-width: 1.2px;
      rx: 10;
      ry: 10;
    }

    .node text {
      font-size: 12px;
      text-anchor: middle;
      dominant-baseline: middle;
    }

    .link {
      fill: none;
      stroke: #999;
      stroke-width: 1.2px;
    }

    .painel {
      text-align: center;
      margin-bottom: 10px;
    }

    .painel button,
    .painel select {
      padding: 6px 12px;
      margin: 3px;
    }
  </style>
</head>
<body>
  <h2>üìò Organograma Fazenda ‚Üí √Årea ‚Üí L√≠der ‚Üí Liderados</h2>

  <div class="painel">
    <input type="file" id="inputExcel" accept=".xlsx, .xls">
    <select id="filtroArea">
      <option value="">Todas as √Åreas</option>
    </select>
    <br>
    <button id="expandir">Expandir Todos</button>
    <button id="recolher">Recolher Todos</button>
  </div>

  <svg id="svg"></svg>

  <script>
    const colunaFazenda = "Fazenda";
    const colunaArea = "Setor";
    const colunaLider = "L√≠der";
    const colunaLiderado = "Liderado";

    document.getElementById("inputExcel").addEventListener("change", function (e) {
      const arquivo = e.target.files[0];
      if (!arquivo) return;

      const leitor = new FileReader();
      leitor.onload = function (evento) {
        const dados = new Uint8Array(evento.target.result);
        const workbook = XLSX.read(dados, { type: "array" });
        const planilha = workbook.Sheets[workbook.SheetNames[0]];
        const json = XLSX.utils.sheet_to_json(planilha);

        const linhasValidas = json.filter(l =>
          l[colunaFazenda] && l[colunaArea] && l[colunaLider] && l[colunaLiderado]
        );

        const filtroArea = document.getElementById("filtroArea");
        const areasUnicas = [...new Set(linhasValidas.map(l => l[colunaArea].toString().trim()))];
        filtroArea.innerHTML = '<option value="">Todas as √Åreas</option>';
        areasUnicas.forEach(area => {
          const opt = document.createElement("option");
          opt.value = area;
          opt.textContent = area;
          filtroArea.appendChild(opt);
        });

        const fazendasMap = new Map();
        linhasValidas.forEach(linha => {
          const fazenda = linha[colunaFazenda].toString().trim();
          const area = linha[colunaArea].toString().trim();
          const lider = linha[colunaLider].toString().trim();
          const liderado = linha[colunaLiderado].toString().trim();

          if (!fazendasMap.has(fazenda)) fazendasMap.set(fazenda, new Map());
          const areasMap = fazendasMap.get(fazenda);

          if (!areasMap.has(area)) areasMap.set(area, new Map());
          const lideresMap = areasMap.get(area);

          if (!lideresMap.has(lider)) lideresMap.set(lider, []);
          lideresMap.get(lider).push(liderado);
        });

        const dadosHierarquia = {
          name: "Grupo Michels",
          children: Array.from(fazendasMap.entries()).map(([fazenda, areasMap]) => ({
            name: fazenda,
            children: Array.from(areasMap.entries()).map(([area, lideresMap]) => ({
              name: area,
              children: Array.from(lideresMap.entries()).map(([lider, filhos]) => ({
                name: lider,
                children: filhos.map(f => ({ name: f }))
              }))
            }))
          }))
        };

        desenharOrganograma(dadosHierarquia);

        filtroArea.addEventListener("change", function () {
          const areaSelecionada = this.value;
          if (!areaSelecionada) {
            desenharOrganograma(dadosHierarquia);
            return;
          }

          const fazendasFiltradas = dadosHierarquia.children.map(fazenda => {
            const areasFiltradas = fazenda.children.filter(a => a.name === areaSelecionada);
            return areasFiltradas.length > 0
              ? { ...fazenda, children: areasFiltradas }
              : null;
          }).filter(Boolean);

          const dadosFiltrados = {
            name: dadosHierarquia.name,
            children: fazendasFiltradas
          };

          desenharOrganograma(dadosFiltrados);
        });
      };
      leitor.readAsArrayBuffer(arquivo);
    });

    // ==========================================================
    // DESENHAR ORGANOGRAMA
    // ==========================================================
    function desenharOrganograma(dados) {
      const svg = d3.select("#svg");
      svg.selectAll("*").remove();

      const width = window.innerWidth;
      const nodeWidth = 150;
      const nodeHeight = 70;

      const g = svg.append("g").attr("transform", `translate(${width / 2}, 60)`);
      const root = d3.hierarchy(dados);

      let i = 0;
      root.each(d => { d.id = ++i; d.x0 = 0; d.y0 = 0; });

      const zoom = d3.zoom()
        .scaleExtent([0.3, 2])
        .on("zoom", e => g.attr("transform", e.transform));
      svg.call(zoom);

      // ---------- LAYOUT VERTICAL ----------
      function layoutVertical(node, nivel = 0, xInicio = 0) {
        const larguraNo = nodeWidth + 120;
        const alturaNo = nodeHeight + 120;
        node.y = nivel * alturaNo;
        node.x = xInicio;

        if (!node.children || node.children.length === 0) return larguraNo;

        let larguraTotal = 0;
        node.children.forEach((filho) => {
          const larguraSub = layoutVertical(filho, nivel + 1, xInicio + larguraTotal);
          larguraTotal += larguraSub;
        });

        const larguraPai = larguraTotal - larguraNo;
        const centroFilhos = xInicio + larguraPai / 2;
        node.x = centroFilhos;

        return larguraTotal;
      }

      layoutVertical(root);
      update(root);
      centralizar();

      // ---------- BOT√ïES ----------
      document.getElementById("expandir").onclick = () => expandCollapseAll(true);
      document.getElementById("recolher").onclick = () => expandCollapseAll(false);

      function expandCollapseAll(expandir) {
        root.descendants().forEach(d => {
          if (expandir && d._children) {
            d.children = d._children;
            d._children = null;
          } else if (!expandir && d.children) {
            d._children = d.children;
            d.children = null;
          }
        });
        layoutVertical(root);
        update(root);
      }

      function centralizar() {
        const bbox = g.node().getBBox();
        const escala = 0.9;
        const xCentro = width / 2 - (bbox.x + bbox.width / 2);
        const yInicio = 60;
        const t = d3.zoomIdentity.translate(xCentro, yInicio).scale(escala);
        svg.transition().duration(600).call(zoom.transform, t);
      }

      // ---------- LINHAS (COTOVELOS RETOS) ----------
      function diagonal(d) {
        const x1 = d.source.x - width / 2;
        const y1 = d.source.y + nodeHeight / 2;
        const x2 = d.target.x - width / 2;
        const y2 = d.target.y - nodeHeight / 2;
        return `M${x1},${y1} L${x1},${(y1 + y2) / 2} L${x2},${(y1 + y2) / 2} L${x2},${y2}`;
      }

      // ---------- UPDATE ----------
      function update(source) {
        layoutVertical(root);
        const nodes = root.descendants();
        const links = root.links();

        // JOIN NODES
        const node = g.selectAll("g.node").data(nodes, d => d.id);

        const nodeEnter = node.enter().append("g")
          .attr("class", "node")
          .attr("transform", d => `translate(${source.x0 - width / 2},${source.y0})`)
          .on("click", (event, d) => {
            if (d.children || d._children) toggleChildren(d);
          });

        nodeEnter.append("rect")
          .attr("x", -nodeWidth / 2)
          .attr("y", -nodeHeight / 2)
          .attr("width", nodeWidth)
          .attr("height", nodeHeight)
          .attr("fill", d => {
            if (d.depth === 0) return "#fff9c4";
            if (d.depth === 1) return "#b2dfdb";
            if (d.depth === 2) return "#bbdefb";
            if (d.depth === 3) return "#c8e6c9";
            return "#e1bee7";
          });

        nodeEnter.append("text")
          .text(d => d.data.name)
          .attr("font-size", 12)
          .attr("x", 0)
          .attr("y", 0);

        const nodeUpdate = nodeEnter.merge(node);
        nodeUpdate.transition().duration(500)
          .attr("transform", d => `translate(${d.x - width / 2},${d.y})`);

        node.exit().transition().duration(500)
          .attr("transform", d => `translate(${source.x - width / 2},${source.y})`)
          .remove();

        // JOIN LINKS
        const link = g.selectAll("path.link")
          .data(links, d => d.target.id);

        link.enter().insert("path", "g")
          .attr("class", "link")
          .attr("d", () => diagonal({
            source: { x: source.x, y: source.y },
            target: { x: source.x, y: source.y }
          }))
          .merge(link)
          .transition().duration(500)
          .attr("d", d => diagonal(d));

        link.exit().transition().duration(500)
          .attr("d", () => diagonal({
            source: { x: source.x, y: source.y },
            target: { x: source.x, y: source.y }
          }))
          .remove();

        nodes.forEach(d => { d.x0 = d.x; d.y0 = d.y; });
      }

      // ---------- EXPAND/COLLAPSE ----------
      function toggleChildren(d) {
        if (d.children) {
          d._children = d.children;
          d.children = null;
        } else if (d._children) {
          d.children = d._children;
          d._children = null;
        } else {
          return;
        }
        update(d);
      }
    }
  </script>
</body>
</html>
