<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <title>Organograma Fazenda ‚Üí √Årea ‚Üí L√≠der ‚Üí Liderados</title>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <style>
        body {
            font-family: Arial, sans-serif;
            background: #f4f4f4;
            margin: 20px;
            overflow: hidden;
        }

        h2 {
            text-align: center;
        }

        svg {
            width: 100%;
            height: 85vh;
            border: 1px solid #ccc;
            background: #fff;
        }

        .node rect {
            stroke: #4285f4;
            stroke-width: 1.2px;
            rx: 10;
            ry: 10;
        }

        .node text {
            font-size: 12px;
            text-anchor: middle;
            dominant-baseline: middle;
        }

        .link {
            fill: none;
            stroke: #999;
            stroke-width: 1.2px;
        }

        .painel {
            text-align: center;
            margin-bottom: 10px;
        }

        .painel button,
        .painel select {
            padding: 6px 12px;
            margin: 3px;
        }
    </style>
</head>

<body>
    <h2>üìò Organograma Fazenda ‚Üí √Årea ‚Üí L√≠der ‚Üí Liderados</h2>

    <div class="painel">
        <input type="file" id="inputExcel" accept=".xlsx, .xls">
        <select id="filtroArea">
            <option value="">Todas as √Åreas</option>
        </select>
        <select id="filtroFazenda">
            <option value="">Todas as Fazendas</option>
        </select>
        <br>
        <button id="expandir">Expandir Todos</button>
        <button id="recolher">Recolher Todos</button>
    </div>

    <svg id="svg"></svg>

    <script>
        const colunaFazenda = "Fazenda";
        const colunaArea = "Setor";
        const colunaLider = "L√≠der";
        const colunaLiderado = "Liderado";

        document.getElementById("inputExcel").addEventListener("change", function (e) {
            const arquivo = e.target.files[0];
            if (!arquivo) return;

            const leitor = new FileReader();
            leitor.onload = function (evento) {
                const dados = new Uint8Array(evento.target.result);
                const workbook = XLSX.read(dados, { type: "array" });
                const planilha = workbook.Sheets[workbook.SheetNames[0]];
                const json = XLSX.utils.sheet_to_json(planilha);

                const linhasValidas = json.filter(l =>
                    l[colunaFazenda] && l[colunaArea] && l[colunaLider] && l[colunaLiderado]
                );

                const filtroArea = document.getElementById("filtroArea");
                const areasUnicas = [...new Set(linhasValidas.map(l => l[colunaArea].toString().trim()))];
                filtroArea.innerHTML = '<option value="">Todas as √Åreas</option>';
                areasUnicas.forEach(area => {
                    const opt = document.createElement("option");
                    opt.value = area;
                    opt.textContent = area;
                    filtroArea.appendChild(opt);
                });

                const filtroFazenda = document.getElementById("filtroFazenda");
                const fazendasUnicas = [...new Set(linhasValidas.map(l => l[colunaFazenda].toString().trim()))];
                filtroFazenda.innerHTML = '<option value="">Todas as Fazendas</options>';
                fazendasUnicas.forEach(fazenda =>{
                    const opt = document.createElement("option");
                    opt.value = fazenda;
                    opt.textContent = fazenda;
                    filtroFazenda.appendChild(opt) ;
                }

                )        




                const fazendasMap = new Map();
                linhasValidas.forEach(linha => {
                    const fazenda = linha[colunaFazenda].toString().trim();
                    const area = linha[colunaArea].toString().trim();
                    const lider = linha[colunaLider].toString().trim();
                    const liderado = linha[colunaLiderado].toString().trim();

                    if (!fazendasMap.has(fazenda)) fazendasMap.set(fazenda, new Map());
                    const areasMap = fazendasMap.get(fazenda);

                    if (!areasMap.has(area)) areasMap.set(area, new Map());
                    const lideresMap = areasMap.get(area);

                    if (!lideresMap.has(lider)) lideresMap.set(lider, []);
                    lideresMap.get(lider).push(liderado);
                });

                const dadosHierarquia = {
                    name: "Grupo Michels",
                    children: Array.from(fazendasMap.entries()).map(([fazenda, areasMap]) => ({
                        name: fazenda,
                        children: Array.from(areasMap.entries()).map(([area, lideresMap]) => ({
                            name: area,
                            children: Array.from(lideresMap.entries()).map(([lider, filhos]) => ({
                                name: lider,
                                children: filhos.map(f => ({ name: f }))
                            }))
                        }))
                    }))
                };

                desenharOrganograma(dadosHierarquia);

                filtroArea.addEventListener("change", function () {
                    const areaSelecionada = this.value;
                    if (!areaSelecionada) {
                        desenharOrganograma(dadosHierarquia);
                        return;
                    }

                    const fazendasFiltradas = dadosHierarquia.children.map(fazenda => {
                        const areasFiltradas = fazenda.children.filter(a => a.name === areaSelecionada);
                        return areasFiltradas.length > 0
                            ? { ...fazenda, children: areasFiltradas }
                            : null;
                    }).filter(Boolean);

                    const dadosFiltrados = {
                        name: dadosHierarquia.name,
                        children: fazendasFiltradas
                    };

                    desenharOrganograma(dadosFiltrados);
                });
            };
            leitor.readAsArrayBuffer(arquivo);
        });

        // ==========================================================
        // DESENHAR ORGANOGRAMA
        // ==========================================================
        function desenharOrganograma(dados) {
            const svg = d3.select("#svg");
            svg.selectAll("*").remove();

            const width = window.innerWidth;
            const nodeWidth = 150;
            const nodeHeight = 70;

            const g = svg.append("g").attr("transform", `translate(${width / 2}, 60)`);
            const root = d3.hierarchy(dados);

            let i = 0;
            root.each(d => { d.id = ++i; d.x0 = 0; d.y0 = 0; });

            const zoom = d3.zoom()
                .scaleExtent([0.3, 2])
                .on("zoom", e => g.attr("transform", e.transform));
            svg.call(zoom);

            // ---------- LAYOUT VERTICAL ----------
            function layoutVertical(node, nivel = 0, xInicio = 0) {
                const larguraNo = nodeWidth + 120;
                const alturaNo = nodeHeight + 120;
                node.y = nivel * alturaNo;
                node.x = xInicio;

                if (!node.children || node.children.length === 0) return larguraNo;

                let larguraTotal = 0;
                node.children.forEach((filho) => {
                    const larguraSub = layoutVertical(filho, nivel + 1, xInicio + larguraTotal);
                    larguraTotal += larguraSub;
                });

                const larguraPai = larguraTotal - larguraNo;
                const centroFilhos = xInicio + larguraPai / 2;
                node.x = centroFilhos;

                return larguraTotal;
            }

            layoutVertical(root);
            update(root);
            // centralizar();
            centralizarOrganograma();

            // ---------- BOT√ïES ----------
            document.getElementById("expandir").onclick = () => {
                expandCollapseAll(true);
                centralizarOrganograma(); // sempre centraliza o n√≥ raiz
            };
            document.getElementById("recolher").onclick = () => {
                expandCollapseAll(false);
                centralizarOrganograma(); // idem
            };


            // ---------- CENTRALIZAR ORGANOGRAMA AO MEIO ----------
            function centralizarOrganograma() {
                // Seleciona SVG e grupo principal
                const svgWidth = parseFloat(svg.style("width"));
                const svgHeight = parseFloat(svg.style("height"));

                // Pega o n√≥ raiz (n√≠vel 0)
                const rootNode = root; // j√° definido dentro de desenharOrganograma()

                // Pega o zoom atual
                const transform = d3.zoomTransform(svg.node());
                const scale = transform.k || 1;

                // Calcula posi√ß√£o do n√≥ raiz
                const xRoot = rootNode.x - width / 2;
                const yRoot = rootNode.y;

                // Centraliza o n√≥ raiz no meio do SVG
                const x = svgWidth / 2 - xRoot * scale;
                const y = svgHeight / 2 - yRoot * scale;

                // Aplica o movimento com transi√ß√£o suave
                svg.transition()
                    .duration(800)
                    .call(zoom.transform, d3.zoomIdentity.translate(x, y).scale(scale));
            }



            function centralizar() {
                const bbox = g.node().getBBox();
                const escala = 0.9;
                const xCentro = width / 2 - (bbox.x + bbox.width / 2);
                const yInicio = 60;
                const t = d3.zoomIdentity.translate(xCentro, yInicio).scale(escala);
                svg.transition().duration(600).call(zoom.transform, t);
            }

            // ---------- LINHAS (COTOVELOS RETOS) ----------
            function diagonal(d) {
                const x1 = d.source.x - width / 2;
                const y1 = d.source.y + nodeHeight / 2;
                const x2 = d.target.x - width / 2;
                const y2 = d.target.y - nodeHeight / 2;
                return `M${x1},${y1} L${x1},${(y1 + y2) / 2} L${x2},${(y1 + y2) / 2} L${x2},${y2}`;
            }

            // ---------- QUEBRA DE TEXTO ----------
            function wrapText(textSelection, text, width) {
                const maxChars = Math.floor(width / 8);
                const words = text.split(/\s+/);
                let lines = [];
                let currentLine = "";

                words.forEach(word => {
                    if ((currentLine + " " + word).trim().length <= maxChars) {
                        currentLine = (currentLine + " " + word).trim();
                    } else {
                        lines.push(currentLine);
                        currentLine = word;
                    }
                });
                if (currentLine) lines.push(currentLine);

                if (lines.length > 3) {
                    lines = lines.slice(0, 3);
                    let last = lines[2];
                    if (!last.endsWith("...")) lines[2] = last + "...";
                }

                textSelection.text(null);
                const lineHeight = 1.2;
                const totalHeight = lines.length * 14;
                const offsetY = -totalHeight / 2 + 6;

                lines.forEach((line, i) => {
                    textSelection.append("tspan")
                        .attr("x", 0)
                        .attr("y", offsetY + i * 14)
                        .text(line);
                });
            }

            // ---------- UPDATE ----------
            function update(source) {
                layoutVertical(root);
                const nodes = root.descendants();
                const links = root.links();

                // JOIN NODES
                const node = g.selectAll("g.node").data(nodes, d => d.id);

                const nodeEnter = node.enter().append("g")
                    .attr("class", "node")
                    .attr("transform", d => `translate(${source.x0 - width / 2},${source.y0})`)
                    .on("click", (event, d) => {
                        if (d.children || d._children) toggleChildren(d);
                    });

                nodeEnter.append("rect")
                    .attr("x", -nodeWidth / 2)
                    .attr("y", -nodeHeight / 2)
                    .attr("width", nodeWidth)
                    .attr("height", nodeHeight)
                    .attr("fill", d => {
                        if (d.depth === 0) return "#fff9c4";
                        if (d.depth === 1) return "#b2dfdb";
                        if (d.depth === 2) return "#bbdefb";
                        if (d.depth === 3) return "#c8e6c9";
                        return "#e1bee7";
                    });

                nodeEnter.append("text")
                    .attr("font-size", 12)
                    .each(function (d) {
                        const t = d3.select(this);
                        wrapText(t, d.data.name, nodeWidth);
                    });

                const nodeUpdate = nodeEnter.merge(node);
                nodeUpdate.transition().duration(500)
                    .attr("transform", d => `translate(${d.x - width / 2},${d.y})`);

                node.exit().transition().duration(500)
                    .attr("transform", d => `translate(${source.x - width / 2},${source.y})`)
                    .remove();

                // JOIN LINKS
                const link = g.selectAll("path.link")
                    .data(links, d => d.target.id);

                link.enter().insert("path", "g")
                    .attr("class", "link")
                    .attr("d", () => diagonal({
                        source: { x: source.x, y: source.y },
                        target: { x: source.x, y: source.y }
                    }))
                    .merge(link)
                    .transition().duration(500)
                    .attr("d", d => diagonal(d));

                link.exit().transition().duration(500)
                    .attr("d", () => diagonal({
                        source: { x: source.x, y: source.y },
                        target: { x: source.x, y: source.y }
                    }))
                    .remove();

                nodes.forEach(d => { d.x0 = d.x; d.y0 = d.y; });
            }

            // ---------- EXPAND/COLLAPSE ----------
            function expandCollapseAll(expandir) {
                root.descendants().forEach(d => {
                    if (expandir && d._children) {
                        d.children = d._children;
                        d._children = null;
                    } else if (!expandir && d.children) {
                        d._children = d.children;
                        d.children = null;
                    }
                });
                layoutVertical(root);
                update(root);
            }

            function toggleChildren(d) {
                if (d.children) {
                    d._children = d.children;
                    d.children = null;
                } else if (d._children) {
                    d.children = d._children;
                    d._children = null;
                } else {
                    return;
                }
                update(d);
            }
        }
    </script>
</body>

</html>