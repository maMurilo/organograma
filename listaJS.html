<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <title>Organograma Fazenda ‚Üí √Årea ‚Üí L√≠der ‚Üí Liderados</title>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <style>
        body {
            font-family: Arial, sans-serif;
            background: #f4f4f4;
            margin: 20px;
            overflow: hidden;
        }

        h2 {
            margin-bottom: 10px;
            text-align: center;
        }

        svg {
            width: 100%;
            height: 85vh;
            border: 1px solid #ccc;
            background: #fff;
        }

        .node rect {
            stroke: #4285f4;
            stroke-width: 1.2px;
            rx: 10;
            ry: 10;
        }

        .node text {
            font-size: 12px;
            text-anchor: middle;
            dominant-baseline: middle;
        }

        .link {
            fill: none;
            stroke: #999;
            stroke-width: 1.2px;
        }

        .painel {
            text-align: center;
            margin-bottom: 10px;
        }

        .painel button,
        .painel select {
            padding: 6px 12px;
            margin: 3px;
        }
    </style>
</head>

<body>
    <h2>üìò Organograma Fazenda ‚Üí √Årea ‚Üí L√≠der ‚Üí Liderados</h2>

    <div class="painel">
        <input type="file" id="inputExcel" accept=".xlsx, .xls">
        <select id="filtroArea">
            <option value="">Todas as √Åreas</option>
        </select>
        <br>
        <button id="expandir">Expandir Todos</button>
        <button id="recolher">Recolher Todos</button>
        <button id="expandirFazenda">Expandir at√© Fazenda</button>
        <button id="recolherFazenda">Recolher at√© Fazenda</button>
    </div>

    <svg id="svg"></svg>

    <script>
        const colunaFazenda = "Fazenda";
        const colunaArea = "Setor";
        const colunaLider = "L√≠der";
        const colunaLiderado = "Liderado";

        // ==========================================================
        // LEITURA DO EXCEL E MONTAGEM DA HIERARQUIA
        // ==========================================================
        document.getElementById("inputExcel").addEventListener("change", function (e) {
            const arquivo = e.target.files[0];
            if (!arquivo) return;

            const leitor = new FileReader();
            leitor.onload = function (evento) {
                const dados = new Uint8Array(evento.target.result);
                const workbook = XLSX.read(dados, { type: "array" });
                const planilha = workbook.Sheets[workbook.SheetNames[0]];
                const json = XLSX.utils.sheet_to_json(planilha);

                // Filtra linhas v√°lidas
                const linhasValidas = json.filter(l =>
                    l[colunaFazenda] && l[colunaArea] && l[colunaLider] && l[colunaLiderado]
                );

                // --- Preenche o filtro de √°rea ---
                const filtroArea = document.getElementById("filtroArea");
                const areasUnicas = [...new Set(linhasValidas.map(l => l[colunaArea].toString().trim()))];
                filtroArea.innerHTML = '<option value="">Todas as √Åreas</option>';
                areasUnicas.forEach(area => {
                    const opt = document.createElement("option");
                    opt.value = area;
                    opt.textContent = area;
                    filtroArea.appendChild(opt);
                });

                // === AGRUPAR ===
                const fazendasMap = new Map();
                linhasValidas.forEach(linha => {
                    const fazenda = linha[colunaFazenda].toString().trim();
                    const area = linha[colunaArea].toString().trim();
                    const lider = linha[colunaLider].toString().trim();
                    const liderado = linha[colunaLiderado].toString().trim();

                    if (!fazendasMap.has(fazenda)) fazendasMap.set(fazenda, new Map());
                    const areasMap = fazendasMap.get(fazenda);

                    if (!areasMap.has(area)) areasMap.set(area, new Map());
                    const lideresMap = areasMap.get(area);

                    if (!lideresMap.has(lider)) lideresMap.set(lider, []);
                    lideresMap.get(lider).push(liderado);
                });

                // === CONVERTER PARA OBJETO HIER√ÅRQUICO ===
                const dadosHierarquia = {
                    name: "Grupo Michesl",
                    children: Array.from(fazendasMap.entries()).map(([fazenda, areasMap]) => ({
                        name: fazenda,
                        children: Array.from(areasMap.entries()).map(([area, lideresMap]) => ({
                            name: area,
                            children: Array.from(lideresMap.entries()).map(([lider, filhos]) => ({
                                name: lider,
                                children: filhos.map(f => ({ name: f }))
                            }))
                        }))
                    }))
                };

                desenharOrganograma(dadosHierarquia);

                // === FILTRO POR √ÅREA ===
                filtroArea.addEventListener("change", function () {
                    const areaSelecionada = this.value;

                    if (!areaSelecionada) {
                        desenharOrganograma(dadosHierarquia);
                        return;
                    }

                    const fazendasFiltradas = dadosHierarquia.children.map(fazenda => {
                        const areasFiltradas = fazenda.children.filter(a => a.name === areaSelecionada);
                        return areasFiltradas.length > 0
                            ? { ...fazenda, children: areasFiltradas }
                            : null;
                    }).filter(Boolean);

                    const dadosFiltrados = {
                        name: dadosHierarquia.name,
                        children: fazendasFiltradas
                    };

                    desenharOrganograma(dadosFiltrados);
                });
            };
            leitor.readAsArrayBuffer(arquivo);
        });

        // ==========================================================
        // DESENHAR ORGANOGRAMA COM D3
        // ==========================================================
        function desenharOrganograma(dados) {
            const svg = d3.select("#svg");
            svg.selectAll("*").remove();

            const width = window.innerWidth;
            const height = window.innerHeight * 0.85;
            const nodeWidth = 150;
            const nodeHeight = 70;
            const vSpacing = 120;
            const hSpacing = 60;
            const fontFamily = "Arial, sans-serif";
            const fontSize = 11;

            const g = svg.append("g").attr("transform", `translate(${width / 2},60)`);
            const root = d3.hierarchy(dados);

            // Colapsa inicialmente abaixo do n√≠vel 1 (mant√©m fazenda vis√≠vel)
            root.descendants().forEach(d => {
                if (d.depth > 1) {
                    d.hiddenChildren = d.children;
                    d.children = null;
                }
            });

            const treeLayout = d3.tree()
                .nodeSize([nodeWidth + hSpacing, nodeHeight + vSpacing])
                .separation((a, b) => (a.parent === b.parent ? 1.4 : 2));

            const zoom = d3.zoom()
                .scaleExtent([0.3, 2])
                .on("zoom", e => g.attr("transform", e.transform));
            svg.call(zoom);

            // Centraliza automaticamente o gr√°fico
            function centralizar() {
                const bbox = g.node().getBBox();
                const escala = 0.9;
                const xCentro = width / 2 - (bbox.x + bbox.width / 2);
                const yInicio = 60;
                const t = d3.zoomIdentity.translate(xCentro, yInicio).scale(escala);
                svg.transition().duration(600).call(zoom.transform, t);
            }


            function centralizarNoNo(d) {
                const escala = 1.0; // pode ajustar para dar zoom no n√≥ (ex: 1.2)
                const xCentro = width / 2 - (d.x - width / 2) * escala;
                // const yCentro = height / 2 - d.y * escala;
                const yCentro = 10 * escala
                const t = d3.zoomIdentity.translate(xCentro, yCentro).scale(escala);
                svg.transition().duration(600).call(zoom.transform, t);
            }


            root.x0 = 0;
            root.y0 = 0;

            update(root);

            // ---- Bot√µes de expandir/recolher ----
            document.getElementById("expandir").onclick = () => expandCollapseAll(true);
            document.getElementById("recolher").onclick = () => expandCollapseAll(false);
            document.getElementById("expandirFazenda").onclick = () => expandCollapseNivel(true, 1);
            document.getElementById("recolherFazenda").onclick = () => expandCollapseNivel(false, 1);

            // Expande ou recolhe todos
            function expandCollapseAll(expandir) {
                root.descendants().forEach(d => {
                    if (expandir && d.hiddenChildren) {
                        d.children = d.hiddenChildren; d.hiddenChildren = null;
                    } else if (!expandir && d.children) {
                        d.hiddenChildren = d.children; d.children = null;
                    }
                });
                update(root);
            }

            // Expande/recolhe at√© um n√≠vel espec√≠fico (ex: n√≠vel fazenda)
            function expandCollapseNivel(expandir, nivel) {
                root.descendants().forEach(d => {
                    if (d.depth <= nivel) {
                        if (expandir && d.hiddenChildren) {
                            d.children = d.hiddenChildren;
                            d.hiddenChildren = null;
                        }
                    } else {
                        if (!expandir && d.children) {
                            d.hiddenChildren = d.children;
                            d.children = null;
                        }
                    }
                });
                update(root);
            }

            // Atualiza e redesenha
            function update(source) {
                treeLayout(root);

                // LINKS
                const link = g.selectAll(".link")
                    .data(root.links(), d => d.target.data.name);

                const linkEnter = link.enter().insert("path", "g")
                    .attr("class", "link")
                    .attr("d", d => {
                        const o = { x: source.x0 - width / 2, y: source.y0 };
                        return diagonal({ source: o, target: o });
                    });

                linkEnter.merge(link).transition().duration(500)
                    .attr("d", d => diagonal({
                        source: { x: d.source.x - width / 2, y: d.source.y },
                        target: { x: d.target.x - width / 2, y: d.target.y }
                    }));

                link.exit().transition().duration(500)
                    .attr("d", d => {
                        const o = { x: source.x - width / 2, y: source.y };
                        return diagonal({ source: o, target: o });
                    }).remove();

                // NODES
                const node = g.selectAll(".node")
                    .data(root.descendants(), d => d.data.name);

                const nodeEnter = node.enter().append("g")
                    .attr("class", "node")
                    .attr("transform", d => `translate(${source.x0 - width / 2},${source.y0})`)
                    .on("click", (event, d) => {
                        toggleChildren(d);
                        centralizarNoNo(d);
                    });

                nodeEnter.append("rect")
                    .attr("x", -nodeWidth / 2)
                    .attr("y", -nodeHeight / 2)
                    .attr("width", nodeWidth)
                    .attr("height", nodeHeight)
                    .attr("fill", d => {
                        if (d.depth === 1) return "#b2dfdb";
                        if (d.depth === 2) return "#bbdefb";
                        if (d.depth === 3) return "#c8e6c9";
                        return "#fff9c4";
                    });

                nodeEnter.append("text")
                    .attr("font-size", fontSize)
                    .attr("font-family", fontFamily)
                    .each(function (d) {
                        const t = d3.select(this);
                        wrapText(t, d.data.name, nodeWidth - 10);
                        const tspans = t.selectAll("tspan");
                        const n = tspans.size();
                        const offset = -(n * 14) / 2 + 7;
                        tspans.each(function (_, i) {
                            d3.select(this)
                                .attr("x", 0)
                                .attr("y", offset + i * 14);
                        });
                    });

                nodeEnter.merge(node).transition().duration(500)
                    .attr("transform", d => `translate(${d.x - width / 2},${d.y})`);

                node.exit().transition().duration(500)
                    .attr("transform", d => `translate(${source.x - width / 2},${source.y})`)
                    .remove();

                root.eachBefore(d => { d.x0 = d.x; d.y0 = d.y; });

                centralizar(); // üëà sempre centraliza ap√≥s desenhar
            }

            function diagonal(d) {
                return d3.linkVertical().x(d => d.x).y(d => d.y)(d);
            }

            function toggleChildren(d) {
                if (d.children) {
                    d.hiddenChildren = d.children;
                    d.children = null;
                } else {
                    d.children = d.hiddenChildren;
                    d.hiddenChildren = null;
                }
                update(d);
            }
        }

        // ==========================================================
        // QUEBRA DE TEXTO DENTRO DOS N√ìS
        // ==========================================================
        function wrapText(textSelection, text, width) {
            const words = text.split(/\s+/).reverse();
            let line = [];
            let lineNumber = 0;
            const lineHeight = 1.1;
            const y = textSelection.attr("y") || 0;
            const dy = parseFloat(textSelection.attr("dy") || 0);
            let tspan = textSelection.text(null)
                .append("tspan")
                .attr("x", 0)
                .attr("y", y)
                .attr("dy", dy + "em");

            let word;
            while ((word = words.pop())) {
                line.push(word);
                tspan.text(line.join(" "));
                if (tspan.node().getComputedTextLength() > width) {
                    line.pop();
                    tspan.text(line.join(" "));
                    line = [word];
                    tspan = textSelection.append("tspan")
                        .attr("x", 0)
                        .attr("y", y)
                        .attr("dy", ++lineNumber * lineHeight + dy + "em")
                        .text(word);
                }
            }

            if (lineNumber >= 2) textSelection.attr("font-size", 10);
        }
    </script>
</body>

</html>